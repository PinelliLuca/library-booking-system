<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>IoT Seats - Aula</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .controls { display:flex; gap:10px; align-items:center; margin-bottom:12px; }
    .row-container { background-color: #f5f5f5; padding: 10px; margin-bottom: 8px; border-radius: 8px; display:flex; gap:10px; justify-content:center; }
    .tables-area { display:flex; flex-wrap:wrap; gap:24px; justify-content:center; align-items:center; margin-top:18px; padding:8px 0; }
    .table-circle { width:160px; height:160px; position:relative; display:inline-block; }
    .table-surface { width:86px; height:86px; border-radius:50%; background:#caa774; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); box-shadow:0 3px 8px rgba(0,0,0,0.08); }
    .seats-wrapper { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
    .seats-wrapper .seat { position:absolute; pointer-events:auto; }
    .seats-wrapper .seat:hover { transform: translateY(-3px) scale(1.06); box-shadow: 0 6px 14px rgba(0,0,0,0.14); }
    .seats-wrapper .seat:nth-child(1){ left:50%; top:6%; transform:translate(-50%, -50%); }
    .seats-wrapper .seat:nth-child(2){ left:86%; top:26%; transform:translate(-50%,-50%); }
    .seats-wrapper .seat:nth-child(3){ left:86%; top:74%; transform:translate(-50%,-50%); }
    .seats-wrapper .seat:nth-child(4){ left:14%; top:74%; transform:translate(-50%,-50%); }
    .seats-wrapper .seat:nth-child(5){ left:14%; top:26%; transform:translate(-50%,-50%); }
    @media (max-width:720px){ .table-circle{ width:140px;height:140px } .table-surface{ width:76px;height:76px } .seats-wrapper .seat{ width:30px;height:30px;font-size:11px } }
    .seat { width: 34px; height: 34px; border-radius: 50%; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; color:white; font-weight:700; box-shadow: 0 3px 8px rgba(0,0,0,0.12); transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease; font-size: 12px; }
    .seat.free { background: linear-gradient(180deg,#28a745,#1f7a35); }
    .seat.occupied { background: linear-gradient(180deg,#dc3545,#9b2a2a); }
    .seat.pending { background: linear-gradient(180deg, #ffc107, #d39e00); }
    .seat.confirmed { background: linear-gradient(180deg, #0dcaf0, #0aa3c2); }
    .seat:hover { transform: translateY(-3px) scale(1.06); box-shadow: 0 6px 14px rgba(0,0,0,0.14); }
    .seat[title="Placeholder (manca nel DB)"] { opacity: 0.5; cursor:default; pointer-events:none; }
    .legend { display:flex; gap:12px; align-items:center; margin-top:8px; }
    .small-box { width:16px; height:16px; border-radius:3px; display:inline-block; margin-right:6px; vertical-align:middle; }
    .dashboard { margin-top:18px; background:#fff; padding:12px; border-radius:8px; box-shadow:0 1px 4px rgba(0,0,0,0.06); }
    button { padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button.primary { background:#0b5ed7; color:#fff; border-color:#095cb0; }
    button.error { background:#ff0707; color:#fff; border-color:#ff0707; }
    #qr-reader { width: 500px; }
    /* Room grouping */
    .room-section { margin-bottom: 18px; padding: 6px 0; }
    .room-section h3 { font-size: 16px; margin: 8px 0; color: #333; }
    .room-divider { height: 6px; background: linear-gradient(90deg,#f1f1f1,#e6e6e6); border-radius:3px; margin-top:12px; }
    @media (max-width:720px){ .room-divider{ height:4px } }

    /* Modal */
    .modal-overlay { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,0.3); z-index: 9999; }
    .modal { background: #fff; padding: 14px; border-radius: 8px; width: 420px; max-width: calc(100% - 32px); box-shadow: 0 8px 30px rgba(0,0,0,0.18); }
    .modal input[type="datetime-local"] { padding:6px 8px; border-radius:6px; border:1px solid #ccc; }
    .modal h3 { margin:0 0 8px 0; }
    @media (max-width:420px){ .modal{ width:95% } }
  </style>
</head>
<body>
  <div id="app">
    <h1>Aula - Visualizzazione Posti</h1>

    <div class="controls">
      <label>Aggiorna ogni
        <input type="number" v-model.number="pollIntervalSec" style="width:70px; margin-left:6px;" min="5" /> sec
      </label>
      <button @click="fetchSeats" class="primary">Aggiorna ora</button>
      <div style="margin-left:auto;">
        <a v-if="userRole === 'admin'" href="./admin_dashboard" style="margin-right: 15px; text-decoration: none; background: #6c757d; color: white; padding: 6px 10px; border-radius: 6px; font-size: 14px;">Admin Dashboard</a>
        Ciao, <strong>{{ username }}</strong>
      </div>
      <div style="right:20px;top:20px;">
        <button class="error" @click="logout" title="Logout">Logout</button>
      </div>
    </div>
    
    <div v-if="pendingBooking" class="dashboard">
        <h3>Hai una prenotazione in attesa!</h3>
        <p>Posto #{{ pendingBooking.seat_id }} - Scansiona il QR code per confermare.</p>
        <button @click="startScanner" class="primary">Fai Check-in con QR Code</button>
        <div v-if="showScanner">
          <div id="qr-reader" style="margin-top: 10px;"></div>
        </div>
    </div>

    <!-- Seat Suggestions Section -->
    <div class="dashboard" v-if="suggestions.length > 0" style="margin-top: 12px; background: #f0f8ff; border-left: 4px solid #0b5ed7;">
      <h3 style="margin-top: 0; color: #0b5ed7;">ðŸ’¡ Posti Consigliati</h3>
      <p style="font-size: 14px; color: #666; margin: 0 0 10px 0;">
        Basato su occupazione storica, comfort ambientale e efficienza energetica
      </p>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <div v-for="(sugg, idx) in suggestions.slice(0, 5)" :key="'sugg-'+idx"
             style="flex: 0 0 calc(20% - 8px); min-width: 120px; padding: 10px; background: white; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); text-align: center;">
          <div style="font-size: 14px; font-weight: bold; color: #0b5ed7; margin-bottom: 4px;">Posto #{{ sugg.seat_id }}</div>
          <div style="font-size: 12px; color: #28a745; margin-bottom: 6px;">Score: {{ (sugg.score * 100).toFixed(0) }}%</div>
          <!-- <button @click="suggestedBooking(sugg.seat_id)" class="primary" style="width: 100%; font-size: 12px; padding: 4px;">
            Prenota
          </button> -->
        </div>
      </div>
    </div>

    <!-- Booking modal -->
    <div v-if="showBookingModal" class="modal-overlay">
      <div class="modal">
        <h3>Prenota posto #{{ bookingSeat ? bookingSeat.seat_id : '' }}</h3>
        <div style="display:flex; gap:8px; align-items:center; margin:8px 0">
          <label>Inizio:
            <input type="datetime-local" v-model="bookingStart" />
          </label>
          <label>Fine:
            <input type="datetime-local" v-model="bookingEnd" />
          </label>
        </div>
        <div style="color:red; min-height:18px">{{ bookingError }}</div>

        <div v-if="bookingSeatFutureBookings && bookingSeatFutureBookings.length" style="margin-top:10px; font-size:13px; color:#444">
          <h4 style="margin:6px 0 6px">Prenotazioni future per questo posto</h4>
          <ul style="margin:0 0 6px 18px; padding:0;">
            <li v-for="b in bookingSeatFutureBookings" :key="b.id" style="margin-bottom:4px;">
              {{ new Date(b.start_time).toLocaleString() }} - {{ new Date(b.end_time).toLocaleString() }} â€” {{ b.username || 'â€”' }} <span style="color:#0b5ed7; font-weight:600; margin-left:6px;">({{ b.status }})</span>
              <span v-if="b.is_mine" style="margin-left:6px; color:#28a745">â€” Ã¨ tua</span>
            </li>
          </ul>
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px">
          <button @click="closeBookingModal">Annulla</button>
          <button class="primary" @click="createBooking">Conferma prenotazione</button>
        </div>
      </div>
    </div>


    <div v-if="seats.length === 0">Caricamento postiâ€¦</div>

    <div v-else>
      <div class="room-section" v-for="roomGroup in groupedRooms" :key="'room-'+(roomGroup.room.id || roomGroup.room.name)">
        <h3 style="margin:6px 0">{{ roomGroup.room.name }}</h3>
        <div class="tables-area">
          <div class="table-circle" v-for="(row, rIdx) in roomGroup.rows" :key="'table-'+roomGroup.room.id+'-'+rIdx">
            <div class="table-surface" :title="'Tavolo ' + (rIdx + 1)"></div>
            <div class="seats-wrapper">
              <div
                v-for="(seat, sIdx) in row"
                :key="seatKey(seat, rIdx*5 + sIdx)"
                class="seat"
                :class="seatClass(seat)"
                @click="onSeatClick(seat)"
                :title="seatTitle(seat)"
              >
                {{ seatLabel(seat) }}
              </div>
            </div>
          </div>
        </div>
        <div class="room-divider" aria-hidden="true"></div>
      </div>
    </div>

    <div class="legend">
      <div><span class="small-box" style="background:#28a745"></span> Libero</div>
      <div><span class="small-box" style="background:#dc3545"></span> Occupato (Sensore)</div>
      <div><span class="small-box" style="background:#ffc107"></span> Prenotato (In attesa di check-in)</div>
      <div><span class="small-box" style="background:#0dcaf0"></span> Check-in confermato</div>
      <div style="margin-left:auto;">
        <strong>Occupati:</strong> {{ stats.occupied }} / {{ stats.total }} ({{ stats.occupancyPercent }}%)
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          seats: [],
          rooms: [],
          suggestions: [],
          pollIntervalSec: 30,
          pollTimer: null,
          userBookings: [],
          showScanner: false,
          html5QrcodeScanner: null,
          username: '',
          userRole: '',
          // Booking modal state
          showBookingModal: false,
          bookingSeat: null,
          bookingStart: null, // datetime-local string
          bookingEnd: null,
          bookingError: '',
          bookingSeatFutureBookings: []
        }; 
      },
      computed: {
        gridRows() {
          if (!this.seats || this.seats.length === 0) return [];
          const perRow = 5;
          const rows = [];
          for (let i = 0; i < this.seats.length; i += perRow) rows.push(this.seats.slice(i, i + perRow));
          return rows;
        },
        stats() {
          const total = this.seats.length;
          const occupied = this.seats.filter(s => s.is_occupied).length;
          const free = total - occupied;
          const occupancyPercent = total ? Math.round((occupied / total) * 100) : 0;
          return { total, occupied, free, occupancyPercent };
        },
        pendingBooking() {
            const now = new Date();
            return this.userBookings.find(b => {
                if (b.status !== 'pending_checkin' || !b.is_mine) return false;
                try {
                    const start = new Date(b.start_time);
                    const end = new Date(b.end_time);
                    return start <= now && now <= end;
                } catch (e) {
                    // fallback: if date parse fails, consider it not yet pending
                    return false;
                }
            });
        },
        groupedRooms() {
          // Group seats by room_id and chunk into rows of 5
          const map = new Map();
          for (const seat of this.seats) {
            const rid = seat.room_id || 0;
            if (!map.has(rid)) map.set(rid, []);
            map.get(rid).push(seat);
          }
          const result = [];
          for (const [rid, seats] of map.entries()) {
            const perRow = 5;
            const rows = [];
            for (let i = 0; i < seats.length; i += perRow) rows.push(seats.slice(i, i + perRow));
            const room = this.rooms.find(r => r.id === Number(rid)) || { id: rid, name: rid ? `Room ${rid}` : 'Unassigned' };
            result.push({ room, rows });
          }
          // Sort by room id for stable ordering (Unassigned will be first)
          result.sort((a, b) => (Number(a.room.id) || 0) - (Number(b.room.id) || 0));
          return result;
        }
      },
      methods: {
        seatKey(seat, rIdx) {
          if (seat.seat_id) return `id-${seat.seat_id}`;
          return `id-${rIdx}`;
        },
        seatLabel(seat) {
          if (seat.seat_id !== undefined) return `#${seat.seat_id}`;
          return '?';
        },
        seatClass(seat) {
            if (seat.is_occupied) return 'occupied';
            if (seat.booking_status === 'pending_checkin') return 'pending';
            if (seat.booking_status === 'confirmed') return 'confirmed';
            return 'free';
        },
        seatTitle(seat) {
          if (seat.is_occupied) return 'Occupato (sensore)';
          if (seat.booking_status === 'pending_checkin') return 'Prenotato - In attesa di check-in';
          if (seat.booking_status === 'confirmed') return 'Prenotazione confermata';
          return 'Libero';
        },
        
        onSeatClick(seat) {
            if (seat.is_occupied) {
                alert("Questo posto Ã¨ occupato (rilevato dal sensore).");
                return;
            }
            if (!seat.active) {
                alert("Questo posto non Ã¨ prenotabile.");
                return;
            }
            if (seat.booking_status) {
                alert("Questo posto Ã¨ giÃ  prenotato.");
                return;
            }
            console.log(this.pendingBooking);
            if (this.pendingBooking) {
                alert("Hai giÃ  una prenotazione in attesa. Completa prima il check-in.");
                return;
            }

            // Apri il modal di prenotazione con valori di default
            this.openBookingModal(seat);
        },

        openBookingModal(seat) {
          this.bookingSeat = seat;
          this.bookingError = '';
          this.bookingSeatFutureBookings = [];
          const { start, end } = this.getDefaultBookingTimes();
          // datetime-local expects 'YYYY-MM-DDTHH:MM'
          this.bookingStart = start;
          this.bookingEnd = end;
          this.showBookingModal = true;
          // populate future bookings for this seat
          this.fetchBookingsForSeat(seat.seat_id);
        },

        closeBookingModal() {
          this.showBookingModal = false;
          this.bookingSeat = null;
          this.bookingStart = null;
          this.bookingEnd = null;
          this.bookingError = '';
        },

        // Format a 'YYYY-MM-DDTHH:MM' into an ISO string with local offset, e.g. 2026-01-02T14:30:00+01:00
        formatLocalToIsoWithOffset(localStr) {
          if (!localStr) return null;
          const withSeconds = localStr.length === 16 ? `${localStr}:00` : localStr; // add :00 if missing seconds
          // compute offset
          const offsetMin = -new Date().getTimezoneOffset();
          const sign = offsetMin >= 0 ? '+' : '-';
          const absMin = Math.abs(offsetMin);
          const hh = String(Math.floor(absMin / 60)).padStart(2, '0');
          const mm = String(absMin % 60).padStart(2, '0');
          return `${withSeconds}${sign}${hh}:${mm}`;
        },

        getDefaultBookingTimes() {
          const now = new Date();
          // round up to next 30 minutes
          const min = now.getMinutes();
          const add = min === 0 || min <= 30 ? (min <= 30 ? (30 - min) : 60 - min) : 60 - min;
          const start = new Date(now.getTime() + add * 60 * 1000);
          const end = new Date(start.getTime() + 60 * 60 * 1000); // +1h

          function toLocalDatetimeInput(d) {
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const hh = String(d.getHours()).padStart(2, '0');
            const min = String(d.getMinutes()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
          }

          return { start: toLocalDatetimeInput(start), end: toLocalDatetimeInput(end) };
        },

        async createBooking() {
          if (!this.bookingSeat) return;
          if (!this.bookingStart || !this.bookingEnd) {
            this.bookingError = 'Inserisci inizio e fine prenotazione';
            return;
          }

          // Build ISO strings with offset (compatible con datetime.fromisoformat)
          const startIso = this.formatLocalToIsoWithOffset(this.bookingStart);
          const endIso = this.formatLocalToIsoWithOffset(this.bookingEnd);

          // Basic validation
          if (startIso >= endIso) {
            this.bookingError = 'Intervallo non valido (start >= end)';
            return;
          }

          try {
            const payload = {
              seat_id: this.bookingSeat.seat_id,
              start_time: startIso,
              end_time: endIso
            };
            const response = await this.authFetch('/bookings/', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (!response.ok) {
              const err = await response.json().catch(()=>({}));
              this.bookingError = err.message || (err.error || 'Errore nella creazione della prenotazione');
              return;
            }
            // Success
            // refresh bookings list for this seat and overall data
            await this.fetchBookingsForSeat(this.bookingSeat.seat_id);
            this.closeBookingModal();
            alert('Prenotazione creata. Ora effettua il check-in scansionando il QR code sul posto.');
            await this.fetchUserBookings();
            await this.fetchSeats();
          } catch (err) {
            console.error('createBooking error', err);
            this.bookingError = err.message || 'Errore durante la creazione della prenotazione.';
          }
        },


        async fetchUserBookings() {
            try {
                const res = await this.authFetch('/bookings');
                if (!res.ok) throw new Error('Errore nel caricamento delle prenotazioni');
                this.userBookings = await res.json();
            } catch (err) {
                console.error("fetchUserBookings error", err);
            }
        },

        async fetchSuggestions() {
            try {
                const res = await this.authFetch('/seat-suggestions');
                if (!res.ok) {
                    console.error('fetchSuggestions error');
                    return;
                }
                this.suggestions = await res.json();
            } catch (err) {
                console.error('fetchSuggestions failed', err);
            }
        },

        async fetchBookingsForSeat(seatId) {
          try {
            const res = await this.authFetch(`/bookings?seat_id=${seatId}`);
            if (!res.ok) {
              console.error('fetchBookingsForSeat error');
              this.bookingSeatFutureBookings = [];
              return;
            }
            this.bookingSeatFutureBookings = await res.json();
          } catch (err) {
            console.error('fetchBookingsForSeat failed', err);
            this.bookingSeatFutureBookings = [];
          }
        },

        async fetchRooms() {
          try {
            const res = await this.authFetch('/rooms');
            if (!res.ok) {
              console.error('fetchRooms error');
              return;
            }
            this.rooms = await res.json();
          } catch (err) {
            console.error('fetchRooms failed', err);
          }
        },

        startScanner() {
            this.showScanner = !this.showScanner;
            if (this.showScanner) {
              this.$nextTick(() => {
                          this.html5QrcodeScanner = new Html5Qrcode("qr-reader");
                  const config = { fps: 10, qrbox: { width: 250, height: 250 } };
                  // add error callback to surface scan issues
                  this.html5QrcodeScanner.start({ facingMode: "environment" }, config, this.onScanSuccess, (err) => {
                      // console.warn('QR scan error', err);
                      // this.scannerError = (err && err.msg) ? err.msg : String(err);
                      // setTimeout(() => this.scannerError = '', 4000);
                  });
              });
            }
        },

        onScanSuccess(decodedText, decodedResult) {
            if (this.html5QrcodeScanner) {
                this.html5QrcodeScanner.stop().then(() => {
                    this.showScanner = false;
                    this.html5QrcodeScanner = null;
                    // this.scannerError = '';
                    this.performCheckIn(decodedText);
                }).catch(err => console.error("Error stopping scanner", err));
            }
        },

        async performCheckIn(seatIdentifier) {
            try {
                const response = await this.authFetch('/bookings/check-in', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ seat_identifier: seatIdentifier })
                });
                 if (!response.ok) {
                    const err = await response.json().catch(()=>({}));
                    throw new Error(err.error || 'Errore durante il check-in');
                }
                alert('Check-in effettuato con successo!');
                await this.fetchUserBookings();
                await this.fetchSeats();
            } catch (err) {
                console.error('Check-in error', err);
                alert(err.message || 'Errore durante il check-in.');
            }
        },
        
        startPolling() {
          if (this.pollTimer) clearInterval(this.pollTimer);
          this.pollTimer = setInterval(() => this.fetchSeats(), Math.max(5, this.pollIntervalSec) * 1000);
        },
        stopPolling() {
          if (this.pollTimer) clearInterval(this.pollTimer);
          this.pollTimer = null;
        },
        
        getToken() { return localStorage.getItem('iot_jwt'); },
        removeToken() { localStorage.removeItem('iot_jwt'); localStorage.removeItem('iot_username'); },

        logout() {
          this.removeToken();
          window.location.href = './login';
        },

        async authFetch(url, opts = {}) {
          const token = this.getToken();
          if (!token) {
            this.logout();
            throw new Error('Token mancante');
          }

          opts.headers = Object.assign({}, opts.headers || {});
          opts.headers['Authorization'] = `Bearer ${token}`;

          const res = await fetch(url, opts);

          if (res.status === 401 || res.status === 422) {
            this.removeToken();
            window.location.href = './login';
            throw new Error('Token non valido o scaduto');
          }

          return res;
        },

        async fetchSeats() {
          try {
            const res = await this.authFetch('/seats');
            if (!res.ok) {
              const err = await res.json().catch(()=>({}));
              console.error('fetchSeats error', err);
              return;
            }
            this.seats = await res.json();
          } catch (err) {
            console.error('fetchSeats failed', err);
          }
        },
      },
      created() {
        const token = this.getToken();
        if (!token) {
          window.location.href = './login';
        } else {
          this.username = localStorage.getItem('iot_username') || '';
          this.userRole = localStorage.getItem('iot_user_role') || 'student';
          // Load rooms first (so names are available when seats arrive)
          this.fetchRooms();
          this.fetchSeats();
          this.fetchUserBookings();
          this.fetchSuggestions();
        }
      },
      mounted() {
        this.startPolling();
      },
      watch: {
        pollIntervalSec() {
          this.startPolling();
        }
      },
      unmounted() {
        this.stopPolling();
      }
    }).mount('#app');
  </script>
</body>
</html>