<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>IoT Seats - Aula</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .controls { display:flex; gap:10px; align-items:center; margin-bottom:12px; }
    .row-container { background-color: #f5f5f5; padding: 10px; margin-bottom: 8px; border-radius: 8px; display:flex; gap:10px; justify-content:center; }
    .seat { width: 40px; height: 40px; border-radius: 6px; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; color:white; font-weight:600; }
    .seat.free { background: linear-gradient(180deg,#28a745,#1f7a35); }
    .seat.occupied { background: linear-gradient(180deg,#dc3545,#9b2a2a); }
    .legend { display:flex; gap:12px; align-items:center; margin-top:8px; }
    .small-box { width:16px; height:16px; border-radius:3px; display:inline-block; margin-right:6px; vertical-align:middle; }
    .dashboard { margin-top:18px; background:#fff; padding:12px; border-radius:8px; box-shadow:0 1px 4px rgba(0,0,0,0.06); }
    .history-list { max-height:200px; overflow:auto; margin-top:8px; }
    button { padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button.primary { background:#0b5ed7; color:#fff; border-color:#095cb0; }
    button.error { background:#ff0707; color:#fff; border-color:#ff0707; }
  </style>
</head>
<body>
  <div id="app">
    <h1>Aula - Visualizzazione Posti</h1>

    <div class="controls">
      <label>Aggiorna ogni
        <input type="number" v-model.number="pollIntervalSec" style="width:70px; margin-left:6px;" min="5" /> sec
      </label>
      <button @click="fetchSeats" class="primary">Aggiorna ora</button>
      <button @click="toggleDashboard">{{ showDashboard ? 'Nascondi' : 'Mostra' }} dashboard</button>
      <div style="margin-left:auto;">
        <strong>Occupati:</strong> {{ stats.occupied }} / {{ stats.total }} ({{ stats.occupancyPercent }}%)
      </div>
      <!-- logout button top-right -->
      <div style="right:20px;top:20px;">
        <button class="error" @click="logout" title="Logout">Logout</button>
      </div>
    </div>

    <div v-if="gridRows.length === 0">Caricamento posti…</div>

    <div v-for="(row, rIdx) in gridRows" :key="rIdx" class="row-container">
      <div
        v-for="seat in row"
        :key="seatKey(seat, rIdx)"
        class="seat"
        :class="seat.is_occupied ? 'occupied' : 'free'"
        @click="onSeatClick(seat)"
        :title="seatTitle(seat)"
      >
        {{ seatLabel(seat) }}
      </div>
    </div>

    <div class="legend">
      <div><span class="small-box" style="background:#28a745"></span> Libero</div>
      <div><span class="small-box" style="background:#dc3545"></span> Occupato</div>
      <div style="margin-left:12px;color:#666">Clicca su un posto libero per prenotarlo</div>
    </div>

    <div v-if="showDashboard" class="dashboard">
      <h3>Dashboard e Storico</h3>
      <div>
        <strong>Totale posti:</strong> {{ stats.total }} |
        <strong>Occupati:</strong> {{ stats.occupied }} |
        <strong>Libero:</strong> {{ stats.free }}
      </div>

      <div style="margin-top:8px;">
        <label>Filtro storico: 
          <select v-model="historyFilter">
            <option value="all">Tutti</option>
            <option value="reserve">Prenotazioni</option>
            <option value="release">Rilasci</option>
          </select>
        </label>
        <button @click="clearHistory" style="margin-left:8px">Svuota storico locale</button>
      </div>

      <div class="history-list">
        <ul>
          <li v-for="item in filteredHistory" :key="item.ts">
            [{{ new Date(item.ts).toLocaleString() }}] - Posto {{ item.row }},{{ item.column }} - {{ item.action }}
          </li>
          <li v-if="filteredHistory.length === 0" style="color:#666">Nessuna voce</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          seats: [],
          pollIntervalSec: 30,
          pollTimer: null,
          showDashboard: false,
          historyKey: 'reservationHistory',
          historyFilter: 'all',
        };
      },
      computed: {
        // costruisce matrice di righe usando row/column se presenti, altrimenti raggruppa per slot ogni 5
        gridRows() {
          if (!this.seats || this.seats.length === 0) return [];
          const hasRowCol = this.seats.every(s => typeof s.row === 'number' && typeof s.column === 'number');
          if (hasRowCol) {
            const maxRow = Math.max(...this.seats.map(s => s.row));
            const maxCol = Math.max(...this.seats.map(s => s.column));
            const rows = [];
            for (let r = 0; r <= maxRow; r++) {
              const rowSeats = [];
              for (let c = 0; c <= maxCol; c++) {
                const s = this.seats.find(x => x.row === r && x.column === c);
                rowSeats.push(s || { row: r, column: c, is_occupied: true, missing:true }); // placeholder se mancante
              }
              rows.push(rowSeats);
            }
            return rows;
          } else {
            // fallback: chunk every 5
            const perRow = 5;
            const rows = [];
            for (let i = 0; i < this.seats.length; i += perRow) rows.push(this.seats.slice(i, i + perRow));
            return rows;
          }
        },
        stats() {
          const total = this.seats.length;
          const occupied = this.seats.filter(s => s.is_occupied).length;
          const free = total - occupied;
          const occupancyPercent = total ? Math.round((occupied / total) * 100) : 0;
          return { total, occupied, free, occupancyPercent };
        },
        history() {
          try {
            return JSON.parse(localStorage.getItem(this.historyKey) || '[]');
          } catch(e) { return []; }
        },
        filteredHistory() {
          if (this.historyFilter === 'all') return this.history.slice().reverse();
          return this.history.filter(h => (this.historyFilter === 'reserve' ? h.action === 'prenotato' : h.action === 'rilasciato')).reverse();
        }
      },
      methods: {
        seatKey(seat, rIdx) {
          if (seat.id) return `id-${seat.id}`;
          return `r${seat.row || rIdx}-c${seat.column || Math.random()}`;
        },
        seatLabel(seat) {
          if (seat.row !== undefined && seat.column !== undefined) return `${seat.row}-${seat.column}`;
          if (seat.id !== undefined) return `#${seat.id}`;
          return '?';
        },
        seatTitle(seat) {
          if (seat.missing) return 'Placeholder (manca nel DB)';
          return seat.is_occupied ? 'Occupato' : 'Libero';
        },
        async fetchSeats() {
          try {
            const res = await fetch('/seats');
            if (!res.ok) throw new Error('Errore fetch seats');
            const data = await res.json();
            this.seats = data;
          } catch (err) {
            console.error('fetchSeats error', err);
          }
        },
        async onSeatClick(seat) {
          const booking = !seat.is_occupied;
          const actionLabel = booking ? 'Prenotare' : 'Rilasciare';
          const doReserve = confirm(`${actionLabel} il posto ${this.seatLabel(seat)}?`);
          if (!doReserve) return;

          // costruisci endpoint di update: preferisci id se presente, altrimenti row/column
          let patchUrl = null;
          if (seat.id !== undefined) patchUrl = `/seats/${seat.id}`;
          else if (seat.row !== undefined && seat.column !== undefined) patchUrl = `/seats/${seat.row}/${seat.column}`;
          else {
            alert('Impossibile identificare il posto per la prenotazione.');
            return;
          }

          try {
            const res = await fetch(patchUrl, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ is_occupied: true, booking: booking })
            });
            if (!res.ok) {
              const err = await res.json().catch(()=>({})); 
              throw new Error(err.error || 'Errore nella prenotazione');
            }
            // aggiorna view e storico locale
            await this.fetchSeats();
            this.pushHistory({ ts: Date.now(), row: seat.row, column: seat.column, id: seat.id, action: booking ? 'prenotato' : 'rilasciato' });
            alert(booking ? 'Prenotazione eseguita con successo.' : 'Rilascio eseguito con successo.');
          } catch (err) {
            console.error('reserve error', err);
            alert('Errore durante la prenotazione. Controlla il server.');
          }
        },
        pushHistory(entry) {
          const h = this.history;
          h.push(entry);
          localStorage.setItem(this.historyKey, JSON.stringify(h));
        },
        clearHistory() {
          if (!confirm('Svuotare lo storico locale?')) return;
          localStorage.removeItem(this.historyKey);
          alert('Storico cancellato (locale).');
        },
        startPolling() {
          if (this.pollTimer) clearInterval(this.pollTimer);
          this.pollTimer = setInterval(() => this.fetchSeats(), Math.max(5, this.pollIntervalSec) * 1000);
        },
        stopPolling() {
          if (this.pollTimer) clearInterval(this.pollTimer);
          this.pollTimer = null;
        },
        toggleDashboard() {
          this.showDashboard = !this.showDashboard;
        },

        // Token helpers
        getToken() {
          return localStorage.getItem('iot_jwt');
        },
        setToken(token) {
          if (token) localStorage.setItem('iot_jwt', token);
        },
        removeToken() {
          localStorage.removeItem('iot_jwt');
        },

        // logout client-side: cancella token e torna al login
        logout() {
          this.removeToken();
          window.location.href = './login';
        },

        // wrapper fetch che aggiunge Authorization header e gestisce 401/422
        async authFetch(url, opts = {}) {
          const token = this.getToken();
          if (!token) {
            this.logout();
            throw new Error('Token mancante');
          }

          opts.headers = Object.assign({}, opts.headers || {});
          // assicurati di preservare Content-Type se già presente
          opts.headers['Authorization'] = `Bearer ${token}`;

          // se vuoi inviare cookie: opts.credentials = 'include';

          const res = await fetch(url, opts);

          // gestisci token mancante/invalid/scaduto
          if (res.status === 401 || res.status === 422) {
            // pulisci token e rimanda al login
            this.removeToken();
            window.location.href = './login';
            throw new Error('Token non valido o scaduto');
          }

          return res;
        },

        // esempio: uso authFetch per ottenere la lista dei posti
        async fetchSeats() {
          try {
            const res = await this.authFetch('/seats', { method: 'GET' });
            if (!res.ok) {
              const err = await res.json().catch(()=>({}));
              console.error('fetchSeats error', err);
              return;
            }
            const seats = await res.json();
            this.seats = seats;
          } catch (err) {
            console.error('fetchSeats failed', err);
          }
        },

        // esempio: richiesta PATCH per prenotare/rilasciare un posto
        async updateSeat(patchUrl, body) {
          try {
            const res = await this.authFetch(patchUrl, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body)
            });
            if (!res.ok) {
              const err = await res.json().catch(()=>({}));
              throw new Error(err.error || err.message || 'Errore server');
            }
            return await res.json();
          } catch (err) {
            console.error('updateSeat failed', err);
            throw err;
          }
        },

        // esempio di utilizzo: onSeatClick ora usa updateSeat
        async onSeatClick(seat) {
          const booking = !seat.is_occupied;
          if (!confirm(`${booking ? 'Prenotare' : 'Rilasciare'} il posto ${seat.id || (seat.row + ',' + seat.column)}?`)) return;

          let patchUrl = seat.id ? `/seats/${seat.id}` : `/seats/${seat.row}/${seat.column}`;

          try {
            await this.updateSeat(patchUrl, { is_occupied: booking, booking: booking });
            await this.fetchSeats();
            this.pushHistory({ ts: Date.now(), row: seat.row, column: seat.column, id: seat.id, action: booking ? 'prenotato' : 'rilasciato' });
            alert(booking ? 'Prenotazione eseguita con successo.' : 'Rilascio eseguito con successo.');
          } catch (err) {
            alert(err.message || 'Errore operazione');
          }
        }
      },
      created() {
        // controlla presenza token e reindirizza al login se assente
        const token = this.getToken();
        if (!token) {
          window.location.href = './login';
        } else {
          // carica risorse iniziali protette
          this.fetchSeats();
        }
      },
      mounted() {
        // this.fetchSeats();
        this.startPolling();
      },
      watch: {
        pollIntervalSec() {
          this.startPolling();
        }
      },
      unmounted() {
        this.stopPolling();
      }
    }).mount('#app');
  </script>
</body>
</html>